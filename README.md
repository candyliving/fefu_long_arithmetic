### МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ

### Федеральное государственное автономное образовательное учреждение высшего образования

## Дальневосточный федеральный университет
### ИНСТИТУТ МАТЕМАТИКИ И КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ
### Департамент математического и компьютерного моделирования
### ДОКЛАД о практическом задании по дисциплине АИСД

# Эффективная длинная арифметика

### Жадик Кирилл Александрович, гр. Б9121-09.03.03пикд

### г. Владивосток, 2022

# Содержание

[*Содержание*](#содержание)

[*1. Введение*](#1-введение)

[*1.1 Длинная арифметика*](#1.1-длинная-арифметика)

[*1.2 Применение*](#1.2-применение)

[*1.3 Глоссарий*](#1.3-глоссарий)

[*2. Формальная постановка задачи*](#2-формальная-постановка-задачи)

[*3. Формальное описание и реализация алгоритма*](#3-формальное-описание-и-реализация-алгоритма)

[*3.1 Сложение длинных чисел*](#3.1-Сложение-длинных-чисел)

[*3.2 Вычитание длинных чисел*](#3.2-вычитание-длинных-чисел)

[*3.3 Умножение длинных чисел*](#3.3-Умножение-длинных-чисел)

[*3.4 Деление длинных чисел*](#3.4-Деление-длинных-чисел)

[*4. Тестирование*](#4.-Тестирование)

[*5. Заключение*](#5.-Заключение)

[*Список литературы*](#список-литературы)

# 1 Введение

## 1.1 Длинная арифметика
Длинная арифметика - это метод вычисления с представлением чисел в виде длинных последовательностей цифр, в том числе для вычисления больших чисел, которые не помещаются в стандартные типы данных.

## 1.2 Применение

-	При решении олимпиадных задач.
-	В компьютерах низкой разрядности, микроконтроллерах.
-	Криптография.
-	Математическое и финансовое ПО, требующее, чтобы результат вычисления на компьютере совпал до последнего разряда с результатом вычисления на бумаге. В частности, калькулятор Windows (начиная с 95).
-	«Спортивные» вычисления знаменитых трансцендентных чисел ("число Пи", "число e" и т. д.) с высокой точностью.
-	Высококачественные изображения фракталов.


## 1.3 Глоссарий
1. База длинной арифметики - это максимальное число хранимое в массиве длинной арифметики(base)

2.  Комплексные числа — это числа вида $a + bi$, где $a$ и $b$ это обычные вещественные числа, а $i$ это так называемая мнимая единица: это число, для которого выполняется равенство $i^2 = -1$.

3. Разделяй и властвуй (англ. divide and conquer)  — парадигма разработки алгоритмов, заключающаяся в рекурсивном разбиении решаемой задачи на две или более подзадачи того же типа, но меньшего размера, и комбинировании их решений для получения ответа к исходной задаче

# 2. Формальная постановка задачи 


 В данной работе требуется реализовать операторы длинного сложения, вычитания, умножения, деления наиболее эффективным способом.

# 3. Формальное описание и реализация алгоритма

## 3.1 Сложение длинных чисел
---
Для реализации сложения длинных чисел используем "школьное" сложение в "столбик". Функция сначала уравновешивает длины двух векторов, добавляя начальные нули к более короткому вектору. Затем она выполняет поразрядное сложение, если его результат больше 10, то добавляет единицу к старшему разряду. Наконец, функция возвращает результат, который сохраняется в первом векторе.


## 3.2 Вычитание длинных чисел
---
Вычитание реализуется аналогично сложению. Сначала функция вычисляет разницу в длине между двумя массивами и добавляет нули в начало меньшего массива, чтобы сделать их равной длины. Затем функция выполняет поразрядное вычитание, начиная с последнего элемента массивов. Если результат вычитания отрицательный, функция добавляет к нему 10 и уменьшает следующий элемент на 1. Наконец, функция возвращает вычитаемый массив, который представляет результат вычитания.

## 3.3 Умножение длинных чисел
---
Для умножения длинных чисел использовался алгоритм быстрого преобразования Фурье (БПФ).
#### История алгоритма
По рассказам одного из авторов алгоритма, Джеймса Кули, всё началось в конце 1963 года. Джеймс Кули был нанят в IBM Thomas J. Watson Research Center в Yorktown Heights, что в Нью-Йорке. Кули работал над своим собственным проектом, когда к нему обратился Ричард Гарвин (Richard Garwin) и показал некоторые заметки Джона Тьюки (John Tukey) об алгоритме, который теоретически способен вычислять быстрое преобразование Фурье со скоростью, пропорциональной $N\log_2(N)$, а не $N^2$. Гарвин, в отличие от Кули, хорошо понимал всю важность этого алгоритма и его огромную практическую значимость, и поэтому настаивал на разработке этого алгоритма.

#### Основная цель

Основной задачей быстрого преобразования Фурье (FFT) является эффективное вычисление дискретного преобразования Фурье (DFT). С помощью этого можно умножать многочлены за время $O(nlogn)$.

#### Интерполяция

**Теорема.** Пусть есть набор различных точек $x_0, x_1, \dots, x_{n}$. Многочлен степени $n$ однозначно задаётся своими значениями в этих точках. (Коэффициентов у этого многочлена столько же, сколько и точек — прим. К. О.)

**Доказательство** будет конструктивным — можно явным образом задать многочлен, который принимает заданные значения $y_0, y_1, \ldots, y_n$ в этих точках:

$$
y(x)=\sum\limits_{i=0}^{n}y_i\prod\limits_{j\neq i}\dfrac{x-x_j}{x_i-x_j}
$$

Этот многочлен называется интерполяционным многочленом Лагранжа, а сама задача проведения многочлена через точки — интерполяцией.

![](http://mathworld.wolfram.com/images/eps-gif/LagrangeInterpolatingPoly_900.gif)


#### Дискретное преобразование Фурье (ДПФ)

Дискретным преобразованием Фурье называется вычисление значений многочлена в комплексных корнях из единицы:

$$
y_j = \sum_{k=0}^{n-1} x_n e^{i\tau \frac{kj}{n}} = \sum_{k=0}^{n-1} x_n w_1^{kj}
$$

Обратным дискретным преобразованием Фурье называется обратная операция — интерполяция коэффициентов $x_i$ по значениям $X_i$.

$$
x_j = \frac{1}{n} \sum_{k=0}^{n-1} y_n e^{-i\tau \frac{kj}{n}} = \frac{1}{n} \sum_{k=0}^{n-1} y_n w_{n-1}^{kj}
$$

При вычисление ДПФ мы применяем матрицу к вектору:

$$
\begin{pmatrix}
w^0 & w^0 & w^0 & w^0 & \dots & w^0 \\
w^0 & w^1 & w^2 & w^3 & \dots & w^{-1} \\
w^0 & w^2 & w^4 & w^6 & \dots & w^{-2} \\
w^0 & w^3 & w^6 & w^9 & \dots & w^{-3} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
w^0 & w^{-1} & w^{-2} & w^{-3} & \dots & w^1
\end{pmatrix}\begin{pmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1}
\end{pmatrix} = \begin{pmatrix} y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1}
\end{pmatrix}
$$

#### Быстрое преобразование Фурье

Быстрое преобразование Фурье (fast Fourier transform) — это метод, позволяющий вычислять ДПФ за время $O(n \log n)$. Этот метод основывается на свойствах комплексных корней из единицы (а именно, на том, что степени одних корней дают другие корни).

В первую очередь необходимо поделить все элементы на чётные и нечётные.

Представим многочлен в виде $P(x)=A(x^2)+xB(x^2)$, где $A(x)$ состоит из  коэффициентов при чётных степенях $x$, а $B(x)$ — из коэффициентов при нечётных.

Пусть $n = 2k$. Тогда заметим, что

$$
w^{2t}=w^{2t \bmod 2k}=w^{2(t \bmod k)}
$$

Ключевое замечание: корней вида $w^{2t}$ в два раза меньше, потому что $w^n = w^0$.

Алгоритм для умножения многочленов заключается в следующем: рекурсивно посчитаем БПФ для многочленов $A$ и $B$ и объединим ответы с помощью формулы выше. При этом в рекурсии нам нужно считать значения на корнях степени не $n$, а $k = \frac{n}{2}$, то есть на всех «чётных» корнях степени $n$ (вида $w^{2t}$).


Таким образом, мы свели преобразование размера $n$ к двум преобразованиям размера $\dfrac n 2$. Следовательно, общее время вычислений составит

$$
T(n)=2T\left(\dfrac n 2\right)+O(n)=O(n\log n)
$$

#### Реализация

Рассмотрим простую рекурсивную реализацию БПФ и обратного БПФ, реализуем их в виде одной функции, поскольку различия между прямым и обратным БПФ минимальны. Для хранения комплексных чисел воспользуемся стандартным в C++ STL типом complex.
```c++
void fft(vector<ftype> &a, bool invert) {
    int n = (int) a.size();
    if (n == 1) return;

    vector<ftype> a0(n / 2), a1(n / 2);
    for (int i = 0, j = 0; i < n; i += 2, ++j) {
        a0[j] = a[i];
        a1[j] = a[i + 1];
    }
    fft(a0, invert);
    fft(a1, invert);

    double ang = 2 * pi / n * (invert ? -1 : 1);
    ftype w(1), wn(cos(ang), sin(ang));
    for (int i = 0; i < n / 2; ++i) {
        a[i] = a0[i] + w * a1[i];
        a[i + n / 2] = a0[i] - w * a1[i];
        if (invert)
            a[i] /= 2, a[i + n / 2] /= 2;
        w *= wn;
    }
}
```
В аргумент $\rm a$ функции передаётся входной вектор коэффициентов, в нём же и будет содержаться результат. Аргумент $\rm invert$ показывает, прямое или обратное ДПФ следует вычислить. Внутри функции сначала проверяется, что если длина вектора $\rm a$ равна единице, то ничего делать не надо - он сам и является ответом. Иначе вектор $\rm a$ разделяется на два вектора $\rm a0$ и $\rm a1$, для которых рекурсивно вычисляется ДПФ. Затем вычисляется величина $w_n$, и заводится переменная $w$, содержащая текущую степень $w_n$. Затем вычисляются элементы результирующего ДПФ по вышеописанным формулам.

Если указан флаг $\rm invert = true$, то $w_n$ заменяется на $w_n^{-1}$, а каждый элемент результата делится на 2 (учитывая, что эти деления на 2 произойдут в каждом уровне рекурсии, то в итоге как раз получится, что все элементы поделятся на $n$).

Функция для умножения работает с многочленами с целочисленными коэффициентами (хотя, понятно, теоретически ничто не мешает ей работать и с дробными коэффициентами). Однако здесь проявляется проблема большой погрешности при вычислении ДПФ: погрешность может оказаться значительной, поэтому округлять числа лучше самым надёжным способом — прибавлением 0.5 и последующим округлением вниз.

Функция для перемножения двух длинных чисел практически ничем не отличается от функции для перемножения многочленов. Единственная особенность — что после выполнения умножения чисел как многочлены их следует нормализовать, т.е. выполнить все переносы разрядов.

Источник [13]
### 3.4 Деление длинных чисел

Для начала необходимо реализовать функцю, которая будет сравнивать два числа.
Она будет возвращать $true$ если первое число больши или равно, чем второе, иначе $false$.

Опишим фунцию деления
В начале функция деления обрабатывает исключения: если делитель равен нулю - возвращает $null$, если делитель меньше делимого - возвращает 0. Основной цикл функции проходит по всем цифрам делимого, добавляя их к остатку и деля его на делитель, пока остаток не станет меньше делителя. Количество результатов деления, полученных в этом цикле, добавляется к ответу.

## 4. Тестирование
Основная цель тестирования - проверка корректности и эффективности операций длинной арифметики. Для проверки правильности ответов использовался язык программирования Python, так как операции длинной арифметики встроены в него по умолчанию.

###### Анализ операции сложения
<div>
    <div style="display: flex; justify-content: center">
        <img  src="Images\slozh.png"/>
    </div>
    <p style="font-style: italic; text-align: center">Рисунок 1. График работы операции сложения</p>
</div>

Экспериментальное время линейное  - соответствует теоретической оценке $O(n)$

###### Анализ операции вычитания
<div>
    <div style="display: flex; justify-content: center">
        <img  src="Images\vich.png"/>
    </div>
    <p style="font-style: italic; text-align: center">Рисунок 2. График работы операции вычитания</p>
</div>

Экспериментальное время линейное  - соответствует теоретической оценке $O(n)$

###### Алогоритм быстрого преобразования Фурье
<div>
    <div style="display: flex; justify-content: center">
        <img  src="Images\fft.png"/>
    </div>
    <p style="font-style: italic; text-align: center">Рисунок 3. График работы алгоритма БПФ</p>
</div>

Экспериментальное время соответствует теоретической оценке $O(nlog n)$

###### Анализ операции деления
<div>
    <div style="display: flex; justify-content: center">
        <img  src="Images\del.png"/>
    </div>
    <p style="font-style: italic; text-align: center">Рисунок 4. График работы операции деления</p>
</div>

Экспериментальное время соответствует теоретической оценке $O(n^2)$

###### Общий анализ
Все тесты прошли корректно и полученное время соответсвует теоретической оценке операций.

# 5. Заключение
В результате проведённой работы удалось:

- Изучить материалы о методах длинной арифметики
- Выбрать методы длинной арифметики, которые обеспечат наибольшую эффективность
- Реализовать выбранные методы на ЯП C++
- Выполнить исследование этих методов на производительность и корректность

# Список литературы
---
1.	https://brestprog.by/topics/longarithmetics/
2.	https://e-maxx.ru/algo/big_integer/
3.	https://habr.com/ru/post/172285/
4.	https://habr.com/ru/post/124258/ 
5.	https://wiki.fenix.help/matematika/algoritm-evklida 
6.	https://ru.wikibrief.org/wiki/Division_algorithm 
7.	https://www.stud24.ru/programming-computer/dlinnaya-arifmetika/22260-63531-page1.html
8.	http://comp-science.narod.ru/DL-AR/okulov.htm
9.	https://programforyou.ru/poleznoe/dlinnaya-arifmetika-kak-operirovat-chislami-ne-pomeshchayushchimisya-ni-v-odin-iz-chislovyh-tipov
10.	https://cppalgo.blogspot.com/2010/05/blog-post.html
11.	https://itnan.ru/post.php?c=1&p=578718
12.	https://habr.com/ru/company/otus/blog/449996/
13.	https://ru.wikipedia.org/wiki/Быстрое_преобразование_Фурье
14.	https://algorithmica.org/ru/fft
15.	https://algorithmica.org/ru/karatsuba
16.	https://translated.turbopages.org/proxy_u/en-ru.ru.36bc7c60-633f5d51-e01bf12c-74722d776562/https/en.wikipedia.org/wiki/The_Karatsuba_multiplication
17.	https://www.youtube.com/watch?v=m9yO12Zlb1g&ab_channel=КафедраБИС
18.	https://www.youtube.com/watch?v=21C5cfD6FOo&ab_channel=AGalilov
19.	https://www.youtube.com/watch?v=yL0I2g69EpM&ab_channel=PavelMavrin
20.	https://ru.wikipedia.org/wiki/Длинная_арифметика
21.	http://www.ccas.ru/personal/karatsuba/alg.htm
22.	https://neerc.ifmo.ru/wiki/index.php?title=Арифметика_чисел_в_b-ичной_системе_счисления_(Длинная_арифметика)
23.	https://orenstudent.ru/LongArifmAddSub.htm
24.	https://programforyou.ru/poleznoe/dlinnaya-arifmetika-kak-operirovat-chislami-ne-pomeshchayushchimisya-ni-v-odin-iz-chislovyh-tipov
25.	https://habr.com/ru/post/207754/
26.	https://e-maxx.ru/algo/fft_multiply
27.	https://codeforces.com/blog/entry/1244
